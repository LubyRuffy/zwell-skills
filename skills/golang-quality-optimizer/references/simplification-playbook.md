# Go 代码简化与质量优化清单

目标：**在不改变可观察行为的前提下**，让代码更清晰、更一致、更易测试、更不容易出错。

## 不可破的边界

- 默认不改变：对外 API、返回值语义、错误分类/错误码、并发语义、性能特征（除非明确提升并有验证）。
- 需要行为变化时：先说明“变化点 + 影响面 + 回滚方案/兼容方案”，再动手。

## 聚焦范围

- 默认只改：本次触碰到的文件/函数，以及为保证一致性必须连带修改的少量邻接代码。
- 想扩大范围：先给出收益与风险（例如减少重复、统一错误处理、消除泄漏等），再扩大。

## 简化流程（建议顺序）

1. 先建立基线：能跑的 `go test ./...`、`go vet ./...`、lint/staticcheck。
2. 做结构性简化：减少嵌套、合并重复分支、拆分超长函数但保持高内聚。
3. 做语义性清晰：更好的命名、更明确的返回值与错误、减少跨层泄漏。
4. 做一致性：统一错误 wrap、统一 context 传递、统一日志字段、统一并发收口方式。
5. 回归验证：重复第 1 步；必要时加单测/benchmark/pprof 证明“没坏且更好”。

## 高收益简化手法

- **提前返回**：先处理错误/边界条件，happy path 保持左对齐。
- **消除重复**：把重复条件判断、重复错误构造、重复资源释放抽成局部函数，但避免抽成“无意义层”。
- **明确职责边界**：一个函数做一件事；IO 与纯逻辑分离以利测试。
- **用标准库**：优先 `errors.Is/As`、`context`、`errgroup`、`strings.Builder/Join`、`bytes.Buffer` 等。
- **零值可用**：尽量让结构体零值就能工作（例如避免 nil map 导致 panic）。
- **接收接口，返回结构体**：输入依赖用接口，输出保持具体类型，避免无意义地返回接口。

## 避免“过度简化”

不要为了“更短”而做这些事：

- 写“聪明”一行流（复杂匿名函数、难读的控制流、把多种职责塞进一个函数）。
- 过度抽象：为了复用 2 行代码引入接口/泛型/反射，结果让阅读与调试更困难。
- 把错误吞掉或改成 panic，只为了减少分支。
- 把并发逻辑塞进 helper，让生命周期和取消传播变得不可见。

## Go 特有的质量点（常见坑）

- **错误处理**：错误要带上下文 `fmt.Errorf("op ...: %w", err)`；需要可判别时用 `errors.Is/As` + 哨兵错误/自定义类型。
- **context**：`context.Context` 作为第一个参数；不要塞进 struct 字段；阻塞操作要尊重取消。
- **并发**：每个 goroutine 都要有退出条件；`WaitGroup`/`errgroup`/channel close 责任要明确；避免 goroutine leak。
- **指针/值接收者**：同一类型的方法接收者保持一致（除非有明确理由）。
- **包级状态**：尽量避免全局可变状态；必要时显式注入依赖，便于测试与并发安全。

## 输出要求（给使用者/评审者看的）

- 列出“关键变化点”（3-8 条），强调结构/职责/错误/并发/测试方面的收益。
- 列出验证手段与命令；如果某些工具缺失导致跳过，要明确说明。

